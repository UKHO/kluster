import numpy as np
import xarray as xr

import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, FFMpegWriter
import matplotlib.cm as cm
from matplotlib.colors import LinearSegmentedColormap
from mpl_toolkits.mplot3d import Axes3D  # need this, is used in backend

from HSTB.kluster.xarray_helpers import stack_nan_array


class FqprVisualizations:
    """
    Visualizations in Matplotlib built on top of FQPR class.  Includes animations of beam vectors and vessel
    orientation.

    Processed fqpr_generation.Fqpr instance is passed in as argument
    """

    def __init__(self, fqpr):
        """

        Parameters
        ----------
        fqpr
            Fqpr instance to visualize; fqpr = fully qualified ping record, the term for the datastore in kluster
        """

        self.fqpr = fqpr

        self.orientation_system = None
        self.orientation_quiver = None
        self.orientation_figure = None
        self.orientation_objects = None
        self.orientation_anim = None

        self.raw_bpv_quiver = None
        self.raw_bpv_dat = None
        self.raw_bpv_figure = None
        self.raw_bpv_objects = None
        self.raw_bpv_anim = None

        self.proc_bpv_quiver = None
        self.proc_bpv_dat = None
        self.proc_bpv_figure = None
        self.proc_bpv_objects = None
        self.proc_bpv_anim = None

    def _parse_plot_mode(self, mode: str):
        """
        Used for the soundings plot, parse the mode option and return the variable names to use in the plot, checking
        to see if they are valid for the dataset (self.fqpr)

        Parameters
        ----------
        mode
            One of 'svcorr' and 'georef', which variable you want to visualize

        Returns
        -------
        xvar: string, variable name for the x dimension
        yvar: string, variable name for the y dimension
        zvar: string, variable name for the z dimension
        """

        if mode == 'svcorr':
            xvar = 'alongtrack'
            yvar = 'acrosstrack'
            zvar = 'depthoffset'
        elif mode == 'georef':
            xvar = 'x'
            yvar = 'y'
            zvar = 'z'
        else:
            raise ValueError('Unrecognized mode, must be either "svcorr" or "georef"')

        modechks = [[v in sec] for v in [xvar, yvar, zvar] for sec in self.fqpr.multibeam.raw_ping]
        if not np.any(modechks):
            raise ValueError('{}: Unable to find one or more variables in the raw_ping records'.format(mode))
        return xvar, yvar, zvar

    def soundings_plot_3d(self, mode: str = 'svcorr', color_by: str = 'depth', start_time: float = None, end_time: float = None):
        """
        Plots a 3d representation of the alongtrack/acrosstrack/depth values generated by sv correct.
        If a time is provided, isolates that time.

        Parameters
        ----------
        mode
            str, either 'svcorr' to plot the svcorrected offsets, or 'georef' to plot the georeferenced soundings
        color_by
            str, either 'depth' or 'sector'
        start_time
            start time in utc seconds, optional if you want to subset by time
        end_time
            end time in utc seconds, optional if you want to subset by time

        Returns
        -------
        plt.Axes
            matplotlib axes object for plot
        """

        if start_time is not None or start_time is not None:
            self.fqpr.subset_by_time(start_time, end_time)

        xvar, yvar, zvar = self._parse_plot_mode(mode)

        minz = self.fqpr.calc_min_var(zvar)
        maxz = self.fqpr.calc_max_var(zvar)
        miny = self.fqpr.calc_min_var(yvar)
        maxy = self.fqpr.calc_max_var(yvar)
        if mode == 'svcorr':  # svcorrected is alongtrack/acrosstrack in meters.  Want the scales to be equal so it doesnt look weird
            minx = miny
            maxx = maxy
        else:  # georeferenced is northing/easting, scales cant be equal of course
            minx = self.fqpr.calc_min_var(xvar)
            maxx = self.fqpr.calc_max_var(xvar)

        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')

        for rp in self.fqpr.multibeam.raw_ping:
            x_idx, x_stck = stack_nan_array(rp[xvar], stack_dims=('time', 'beam'))
            y_idx, y_stck = stack_nan_array(rp[yvar], stack_dims=('time', 'beam'))
            z_idx, z_stck = stack_nan_array(rp[zvar], stack_dims=('time', 'beam'))

            if color_by == 'depth':
                ax.scatter(x_stck.values, y_stck.values, z_stck.values, marker='o', s=10, c=z_stck.values)
            elif color_by == 'sector':
                sector_vals = rp.txsector_beam.values[x_idx]
                ax.scatter(x_stck.values, y_stck.values, z_stck.values, marker='o', s=10, c=sector_vals)

        ax.set_xlim(minx, maxx)
        ax.set_ylim(miny, maxy)
        ax.set_zlim(maxz, minz)

        if start_time is not None or start_time is not None:
            self.fqpr.restore_subset()
        return ax

    def soundings_plot_2d(self, mode: str = 'svcorr', color_by: str = 'depth', start_time: float = None, end_time: float = None):
        """
        Plots a 2d representation of the acrosstrack/depth values generated by sv correct.  If sector is
        provided, isolates that sector.  If a time is provided, isolates that time.

        Parameters
        ----------
        mode
            str, either 'svcorr' to plot the svcorrected offsets, or 'georef' to plot the georeferenced soundings
        color_by
            str, either 'depth' or 'sector'
        start_time
            start time in utc seconds, optional if you want to subset by time
        end_time
            end time in utc seconds, optional if you want to subset by time

        Returns
        -------
        plt.Figure
            matplotlib.pyplot.figure instance
        """

        if start_time is not None or start_time is not None:
            self.fqpr.subset_by_time(start_time, end_time)

        xvar, yvar, zvar = self._parse_plot_mode(mode)

        minz = self.fqpr.calc_min_var(zvar)
        maxz = self.fqpr.calc_max_var(zvar)
        miny = self.fqpr.calc_min_var(yvar)
        maxy = self.fqpr.calc_max_var(yvar)
        if mode == 'svcorr':  # svcorrected is alongtrack/acrosstrack in meters.  Want the scales to be equal so it doesnt look weird
            minx = miny
            maxx = maxy
        else:  # georeferenced is northing/easting, scales cant be equal of course
            minx = self.fqpr.calc_min_var(xvar)
            maxx = self.fqpr.calc_max_var(xvar)

        fig = plt.figure()

        for rp in self.fqpr.multibeam.raw_ping:
            x_idx, x_stck = stack_nan_array(rp[xvar], stack_dims=('time', 'beam'))
            y_idx, y_stck = stack_nan_array(rp[yvar], stack_dims=('time', 'beam'))
            z_idx, z_stck = stack_nan_array(rp[zvar], stack_dims=('time', 'beam'))

            if color_by == 'depth':
                plt.scatter(y_stck, x_stck, marker='+', c=z_stck, cmap='coolwarm', s=5)
                plt.clim(minz, maxz)
            elif color_by == 'sector':
                sector_vals = rp.txsector_beam.values[x_idx]
                plt.scatter(y_stck, x_stck, marker='+', c=sector_vals, s=5)
        plt.xlim(miny, maxy)
        plt.ylim(minx, maxx)
        if color_by != 'sector':
            plt.colorbar().set_label(zvar, rotation=270, labelpad=10)
        plt.title('{}: {}/{} colored by {}'.format(mode, xvar, yvar, color_by))

        if start_time is not None or start_time is not None:
            self.fqpr.restore_subset()

        return fig

    def _generate_orientation_vector(self, system_index: int = 0, tme: float = None):
        """
        Generate tx/rx vector data for given time value, return with values to be used with matplotlib quiver

        Parameters
        ----------
        system_index
            int, will automatically choose the first one
        tme
            float, time at this specific interval

        Returns
        -------
        tuple
            x component of starting location of vectors
        tuple
            y component of starting location of vectors
        tuple
            z component of starting location of vectors
        tuple
            x direction component of vectors
        tuple
            y direction component of vectors
        tuple
            z direction component of vectors
        """

        if tme is not None:
            tx = self.fqpr.multibeam.raw_ping[system_index].tx.sel(time=tme).values
            rx = self.fqpr.multibeam.raw_ping[system_index].rx.sel(time=tme).values
        else:
            tx = self.fqpr.multibeam.raw_ping[system_index].tx.isel(time=0).values
            rx = self.fqpr.multibeam.raw_ping[system_index].rx.isel(time=0).values

        rx = np.nanmean(rx, axis=0)
        tx = np.nanmean(tx, axis=0)
        origin = [0, 0, 0]
        x, y, z = zip(origin, origin)
        u, v, w = zip(tx, rx)
        return x, y, z, u, v, w

    def _update_orientation_vector(self, time: float):
        """
        Update method for visualize_orientation_vector, runs on each frame of the animation

        Parameters
        ----------
        time
            float, time at this specific interval
        """

        vecdata = self._generate_orientation_vector(self.orientation_system, time)
        tx_x = round(vecdata[3][0], 3)
        tx_y = round(vecdata[4][0], 3)
        tx_z = round(vecdata[5][0], 3)
        rx_x = round(vecdata[3][1], 3)
        rx_y = round(vecdata[4][1], 3)
        rx_z = round(vecdata[5][1], 3)

        self.orientation_quiver.remove()
        self.orientation_quiver = self.orientation_figure.quiver(*vecdata, color=['blue', 'red'])
        self.orientation_objects['time'].set_text('Time: {:0.3f}'.format(time))
        self.orientation_objects['tx_vec'].set_text('TX Vector: x:{:0.3f}, y:{:0.3f}, z:{:0.3f}'.format(tx_x, tx_y, tx_z))
        self.orientation_objects['rx_vec'].set_text('RX Vector: x:{:0.3f}, y:{:0.3f}, z:{:0.3f}'.format(rx_x, rx_y, rx_z))

    def visualize_orientation_vector(self, system_index: int = 0):
        """
        Use matplotlib funcanimation to build animated representation of the transmitter/receiver across time

        Receiver orientation is based on attitude at the average time of receive (receive time differs across beams)

        Parameters
        ----------
        system_index
            int, optional will automatically choose the first (only matters with dual head, which would have two systems)
        """

        search_for_these = ['tx', 'rx']
        for rec in search_for_these:
            if rec not in self.fqpr.multibeam.raw_ping[system_index]:
                print('visualize_orientation_vector: Unable to find {} record.  Make sure you have run "All Processing - Compute Orientation" first'.format(rec))
                return None

        self.orientation_objects = {}

        self.fqpr.multibeam.raw_ping[system_index]['tx'] = self.fqpr.multibeam.raw_ping[system_index]['tx'].compute()
        self.fqpr.multibeam.raw_ping[system_index]['rx'] = self.fqpr.multibeam.raw_ping[system_index]['rx'].compute()

        fig = plt.figure('Transducer Orientation Vectors', figsize=(10, 8))
        self.orientation_figure = fig.add_subplot(111, projection='3d')
        self.orientation_figure.set_xlim(-1.2, 1.2)
        self.orientation_figure.set_ylim(-1.2, 1.2)
        self.orientation_figure.set_zlim(-1.2, 1.2)
        self.orientation_figure.set_xlabel('+ Forward')
        self.orientation_figure.set_ylabel('+ Starboard')
        self.orientation_figure.set_zlabel('+ Down')

        self.orientation_objects['time'] = self.orientation_figure.text2D(-0.1, 0.11, '')
        self.orientation_objects['tx_vec'] = self.orientation_figure.text2D(0, 0.11, '', color='blue')
        self.orientation_objects['rx_vec'] = self.orientation_figure.text2D(0, 0.10, '', color='red')

        max_range = np.min([100, self.fqpr.multibeam.raw_ping[system_index].time.shape[0]])
        tme_interval = np.mean(np.diff(self.fqpr.multibeam.raw_ping[system_index].time[0:max_range])) * 1000
        print('Animating with frame interval of {}ms per record'.format(int(tme_interval)))

        self.orientation_system = system_index
        self.orientation_quiver = self.orientation_figure.quiver(*self._generate_orientation_vector(system_index),
                                                                 color=['blue', 'red'])
        self.orientation_anim = FuncAnimation(fig, self._update_orientation_vector,
                                              frames=self.fqpr.multibeam.raw_ping[system_index].time.values,
                                              interval=tme_interval)

    def _generate_bpv_arrs(self, dat: xr.Dataset):
        """
        Generate traveltime/beampointingangle vectors to be used with matplotlib quiver

        Parameters
        ----------
        dat
            dataset containing the angle/traveltimes to plot

        Returns
        -------
        tuple
            x component of starting location of vectors
        tuple
            y component of starting location of vectors
        tuple
            x direction component of vectors
        tuple
            y direction component of vectors
        """

        try:  # uncorrected version
            bpa = dat.beampointingangle.values.ravel()
        except:
            bpa = dat.corr_pointing_angle.values.ravel()
        tt = dat.traveltime.values.ravel()

        valid_bpa = ~np.isnan(bpa)
        valid_tt = ~np.isnan(tt)
        valid_idx = np.logical_and(valid_bpa, valid_tt)
        bpa = bpa[valid_idx]
        tt = tt[valid_idx]

        maxbeams = bpa.shape[0]
        u = np.sin(bpa) * tt
        v = np.cos(bpa) * tt
        u = -u / np.max(u)  # negative here for beam pointing angle so the port angles (pos) are on the left side
        v = -v / np.max(v)  # negative here for travel time so the vectors point down in the graph

        x = np.zeros(maxbeams)
        y = np.zeros(maxbeams)
        return x, y, u, v

    def _update_corr_bpv(self, time_idx: int):
        """
        Update method for visualize_beam_pointing_vectors, runs on each frame of the animation

        update for the corrected beam vector viz

        Parameters
        ----------
        time_idx
            int, ping counter index
        """

        subset = self.proc_bpv_dat.isel(time=time_idx)
        angles = subset.corr_pointing_angle.values
        traveltime = subset.traveltime.values
        valid_bpa = ~np.isnan(angles)
        valid_tt = ~np.isnan(traveltime)
        valid_idx = np.logical_and(valid_bpa, valid_tt)
        angles = angles[valid_idx]
        traveltime = traveltime[valid_idx]

        if self.proc_bpv_quiver is not None:
            self.proc_bpv_quiver.remove()
        if self.fqpr.multibeam.is_dual_head():
            subset_next = self.proc_bpv_dat.isel(time=time_idx + 1)
            nextangles = subset_next.corr_pointing_angle.values
            nexttraveltime = subset_next.traveltime.values
            nextvalid_bpa = ~np.isnan(nextangles)
            nextvalid_tt = ~np.isnan(nexttraveltime)
            nextvalid_idx = np.logical_and(nextvalid_bpa, nextvalid_tt)
            nextangles = nextangles[nextvalid_idx]
            nexttraveltime = nexttraveltime[nextvalid_idx]

            pouterang = [str(round(np.rad2deg(angles[0]), 3)), str(round(np.rad2deg(nextangles[0]), 3))]
            poutertt = [str(round(traveltime[0], 3)), str(round(nexttraveltime[0], 3))]
            pinnerang = [str(round(np.rad2deg(angles[-1]), 3)), str(round(np.rad2deg(nextangles[-1]), 3))]
            pinnertt = [str(round(traveltime[-1], 3)), str(round(nexttraveltime[-1], 3))]
            idx = [time_idx, time_idx + 1]
        else:
            pouterang = str(round(np.rad2deg(angles[0]), 3))
            poutertt = str(round(traveltime[0], 3))
            pinnerang = str(round(np.rad2deg(angles[-1]), 3))
            pinnertt = str(round(traveltime[-1], 3))
            idx = time_idx

        self.proc_bpv_quiver = self.proc_bpv_figure.quiver(*self._generate_bpv_arrs(self.proc_bpv_dat.isel(time=idx)),
                                                           color=self._generate_bpv_colors(self.proc_bpv_dat.isel(time=idx)),
                                                           units='xy', scale=1)
        self.proc_bpv_objects['Time'].set_text('Ping: {}'.format(idx))

        self.proc_bpv_objects['Port_outer_angle'].set_text('Port outermost angle: {}°'.format(pouterang))
        self.proc_bpv_objects['Port_outer_traveltime'].set_text('Port outermost traveltime: {}s'.format(poutertt))
        self.proc_bpv_objects['Starboard_outer_angle'].set_text('Starboard outermost angle: {}°'.format(pinnerang))
        self.proc_bpv_objects['Starboard_outer_traveltime'].set_text('Starboard outermost traveltime: {}s'.format(pinnertt))

    def _update_uncorr_bpv(self, time_idx: int):
        """
        Update method for visualize_beam_pointing_vectors, runs on each frame of the animation

        update function for the uncorrected beam vector viz

        Parameters
        ----------
        time_idx
            int, ping counter index
        """

        subset = self.raw_bpv_dat.isel(time=time_idx)
        angles = subset.beampointingangle.values
        traveltime = subset.traveltime.values
        valid_bpa = ~np.isnan(angles)
        valid_tt = ~np.isnan(traveltime)
        valid_idx = np.logical_and(valid_bpa, valid_tt)
        angles = angles[valid_idx]
        traveltime = traveltime[valid_idx]

        if self.raw_bpv_quiver is not None:
            self.raw_bpv_quiver.remove()
        if self.fqpr.multibeam.is_dual_head():
            subset_next = self.raw_bpv_dat.isel(time=time_idx + 1)
            nextangles = subset_next.beampointingangle.values
            nexttraveltime = subset_next.traveltime.values
            nextvalid_bpa = ~np.isnan(nextangles)
            nextvalid_tt = ~np.isnan(nexttraveltime)
            nextvalid_idx = np.logical_and(nextvalid_bpa, nextvalid_tt)
            nextangles = nextangles[nextvalid_idx]
            nexttraveltime = nexttraveltime[nextvalid_idx]

            pouterang = [str(round(np.rad2deg(angles[0]), 3)), str(round(np.rad2deg(nextangles[0]), 3))]
            poutertt = [str(round(traveltime[0], 3)), str(round(nexttraveltime[0], 3))]
            pinnerang = [str(round(np.rad2deg(angles[-1]), 3)), str(round(np.rad2deg(nextangles[-1]), 3))]
            pinnertt = [str(round(traveltime[-1], 3)), str(round(nexttraveltime[-1], 3))]
            idx = [time_idx, time_idx + 1]
        else:
            pouterang = str(round(np.rad2deg(angles[0]), 3))
            poutertt = str(round(traveltime[0], 3))
            pinnerang = str(round(np.rad2deg(angles[-1]), 3))
            pinnertt = str(round(traveltime[-1], 3))
            idx = time_idx

        self.raw_bpv_quiver = self.raw_bpv_figure.quiver(*self._generate_bpv_arrs(self.raw_bpv_dat.isel(time=idx)),
                                                         color=self._generate_bpv_colors(self.raw_bpv_dat.isel(time=idx)),
                                                         units='xy', scale=1)
        self.raw_bpv_objects['Time'].set_text('Ping: {}'.format(idx))

        self.raw_bpv_objects['Port_outer_angle'].set_text('Port outermost angle: {}°'.format(pouterang))
        self.raw_bpv_objects['Port_outer_traveltime'].set_text('Port outermost traveltime: {}s'.format(poutertt))
        self.raw_bpv_objects['Starboard_outer_angle'].set_text('Starboard outermost angle: {}°'.format(pinnerang))
        self.raw_bpv_objects['Starboard_outer_traveltime'].set_text('Starboard outermost traveltime: {}s'.format(pinnertt))

    def _generate_bpv_colors(self, dat: xr.Dataset):
        """
        Return colormap for beams identifying unique sectors as different colors

        Parameters
        ----------
        dat
            dataset of the data for this time

        Returns
        -------
        LinearSegmentedColormap
            matplotlib colormap for that ping, colored by sector
        """

        sec_numbers = []
        max_sector = None
        try:
            num_times = int(dat.time.shape[0])
        except:  # single head, just one time here
            num_times = 1
        for i in range(num_times):  # handle dual head, where you have two pings here
            if num_times != 1:
                subsetdat = dat.isel(time=i)
            else:
                subsetdat = dat
            systemident = subsetdat.system_identifier.values
            sector_numbers = subsetdat.txsector_beam.values.ravel()
            if max_sector is None:
                max_sector = np.max(sector_numbers)
            else:
                max_sector += 1
                sector_numbers += max_sector
            sec_numbers.append(sector_numbers)

        sec_numbers = np.concatenate(sec_numbers)
        colormap = cm.rainbow
        if np.max(sec_numbers) > 0:
            # scale for the max integer count of sectors
            return colormap(sec_numbers / np.max(sec_numbers))
        else:
            return colormap(sec_numbers)

    def visualize_beam_pointing_vectors(self, corrected: bool = False):
        """
        Use matplotlib funcanimation to build animated representation of the beampointingvectors/traveltimes across
        time

        if corrected is True uses the 'corr_pointing_angle' variable that is corrected for mounting angles/attitude,
        otherwise plots the raw 'beampointingangle' variable that is uncorrected.

        Parameters
        ----------
        corrected
            if True uses the 'corr_pointing_angle', else raw beam pointing angle 'beampointingangle'
        """

        if not corrected and ('beampointingangle' not in self.fqpr.multibeam.raw_ping[0]):
            print('visualize_beam_pointing_vectors: Unable to find the raw beampointingangle record, this record comes in during conversion, you must reconvert')
            return None
        elif corrected and ('corr_pointing_angle' not in self.fqpr.multibeam.raw_ping[0]):
            print('visualize_beam_pointing_vectors: Unable to plot the corr_pointing_angle record, Make sure you have run "All Processing - Compute Beam Vectors" first')
            return None

        if corrected:
            fg = plt.figure('Corrected Beam Vectors', figsize=(10, 8))

            self.proc_bpv_objects = {}
            obj = self.proc_bpv_objects
            self.proc_bpv_figure = fg.add_subplot(1, 1, 1)

            self.proc_bpv_figure.set_xlim(-1.5, 1.5)
            self.proc_bpv_figure.set_ylim(-1.5, 0.5)
            self.proc_bpv_figure.set_xlabel('Acrosstrack (scaled)')
            self.proc_bpv_figure.set_ylabel('Travel Time (scaled)')
            self.proc_bpv_figure.set_axis_off()

            obj['Time'] = self.proc_bpv_figure.text(-1.4, 0.45, '')
            obj['Port_outer_angle'] = self.proc_bpv_figure.text(-1.4, 0.40, '')
            obj['Port_outer_traveltime'] = self.proc_bpv_figure.text(-1.4, 0.35, '')
            obj['Starboard_outer_angle'] = self.proc_bpv_figure.text(0.35, 0.40, '')
            obj['Starboard_outer_traveltime'] = self.proc_bpv_figure.text(0.35, 0.35, '')

            self.proc_bpv_dat = self.fqpr.subset_variables(['corr_pointing_angle', 'traveltime', 'txsector_beam'])
            dat = self.proc_bpv_dat
        else:
            fg = plt.figure('Raw Beam Vectors', figsize=(10, 8))

            self.raw_bpv_objects = {}
            obj = self.raw_bpv_objects
            self.raw_bpv_figure = fg.add_subplot(1, 1, 1)

            self.raw_bpv_figure.set_xlim(-1.5, 1.5)
            self.raw_bpv_figure.set_ylim(-1.5, 0.5)
            self.raw_bpv_figure.set_xlabel('Acrosstrack (scaled)')
            self.raw_bpv_figure.set_ylabel('Travel Time (scaled)')
            self.raw_bpv_figure.set_axis_off()

            obj['Time'] = self.raw_bpv_figure.text(-1.4, 0.45, '')
            obj['Port_outer_angle'] = self.raw_bpv_figure.text(-1.4, 0.40, '')
            obj['Port_outer_traveltime'] = self.raw_bpv_figure.text(-1.4, 0.35, '')
            obj['Starboard_outer_angle'] = self.raw_bpv_figure.text(0.35, 0.40, '')
            obj['Starboard_outer_traveltime'] = self.raw_bpv_figure.text(0.35, 0.35, '')

            self.raw_bpv_dat = self.fqpr.subset_variables(['beampointingangle', 'traveltime', 'txsector_beam'])
            self.raw_bpv_dat['beampointingangle'] = np.deg2rad(self.raw_bpv_dat['beampointingangle'])
            dat = self.raw_bpv_dat

        max_range = np.min([100, dat.time.shape[0]])
        tme_interval = np.mean(np.diff(dat.time[0:max_range])) * 1000

        if self.fqpr.multibeam.is_dual_head():  # for dual head, we end up plotting two records each time
            frames = [int(i * 2) for i in range(int(dat.time.shape[0] / 2))]
            tme_interval = tme_interval * 2
        else:
            frames = [i for i in range(int(dat.time.shape[0]))]

        print('Animating with frame interval of {}ms per record'.format(int(tme_interval)))

        if not corrected:
            self.raw_bpv_anim = FuncAnimation(fg, self._update_uncorr_bpv, frames=frames, interval=tme_interval)
        else:
            self.proc_bpv_anim = FuncAnimation(fg, self._update_corr_bpv, frames=frames, interval=tme_interval)


def save_animation_mpeg(anim_instance: FuncAnimation, output_pth: str):
    """
    Save a Matplotlib FuncAnimation object to Mpeg

    Parameters
    ----------
    anim_instance
        Matplotlib FuncAnimation object
    output_pth
        str, path to where you want the mpeg to be generated
    """

    ffwriter = FFMpegWriter()
    anim_instance.save(output_pth, writer=ffwriter)
